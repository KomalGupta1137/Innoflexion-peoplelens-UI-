{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat)); // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n  const prevRawValue = React.useRef();\n  const prevLocale = React.useRef(utils.locale);\n  const prevInputFormat = React.useRef(inputFormat);\n  React.useEffect(() => {\n    const rawValueHasChanged = rawValue !== prevRawValue.current;\n    const localeHasChanged = utils.locale !== prevLocale.current;\n    const inputFormatHasChanged = inputFormat !== prevInputFormat.current;\n    prevRawValue.current = rawValue;\n    prevLocale.current = utils.locale;\n    prevInputFormat.current = inputFormat;\n\n    if (!rawValueHasChanged && !localeHasChanged && !inputFormatHasChanged) {\n      return;\n    }\n\n    const newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    const isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n    const innerEqualsParsed = innerInputValue === null ? newParsedValue === null : newParsedValue !== null && Math.abs(utils.getDiff(innerInputValue, newParsedValue, 'seconds')) === 0;\n\n    if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsParsed)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};","map":{"version":3,"sources":["/home/komal/Documents/Current/peoplelens_ui/node_modules/@mui/x-date-pickers/internals/hooks/useMaskedInput.js"],"names":["_extends","React","useRifm","useUtils","maskedDateFormatter","getDisplayDate","checkMaskIsValidForCurrentFormat","getMaskFromCurrentFormat","useMaskedInput","acceptRegex","disabled","disableMaskedInput","ignoreInvalidInputs","inputFormat","inputProps","label","mask","onChange","rawValue","readOnly","rifmFormatter","TextFieldProps","validationError","utils","formatHelperText","getFormatHelperText","shouldUseMaskedInput","maskToUse","useMemo","computedMaskToUse","formatter","st","parsedValue","date","innerInputValue","setInnerInputValue","useState","innerDisplayedInputValue","setInnerDisplayedInputValue","prevRawValue","useRef","prevLocale","locale","prevInputFormat","useEffect","rawValueHasChanged","current","localeHasChanged","inputFormatHasChanged","newParsedValue","isAcceptedValue","isValid","innerEqualsParsed","Math","abs","getDiff","newDisplayDate","handleChange","text","finalString","parse","undefined","rifmProps","value","format","inputStateArgs","event","currentTarget","error","placeholder","type"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat)); // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n  const prevRawValue = React.useRef();\n  const prevLocale = React.useRef(utils.locale);\n  const prevInputFormat = React.useRef(inputFormat);\n  React.useEffect(() => {\n    const rawValueHasChanged = rawValue !== prevRawValue.current;\n    const localeHasChanged = utils.locale !== prevLocale.current;\n    const inputFormatHasChanged = inputFormat !== prevInputFormat.current;\n    prevRawValue.current = rawValue;\n    prevLocale.current = utils.locale;\n    prevInputFormat.current = inputFormat;\n\n    if (!rawValueHasChanged && !localeHasChanged && !inputFormatHasChanged) {\n      return;\n    }\n\n    const newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    const isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n    const innerEqualsParsed = innerInputValue === null ? newParsedValue === null : newParsedValue !== null && Math.abs(utils.getDiff(innerInputValue, newParsedValue, 'seconds')) === 0;\n\n    if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsParsed)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};"]},"metadata":{},"sourceType":"module"}